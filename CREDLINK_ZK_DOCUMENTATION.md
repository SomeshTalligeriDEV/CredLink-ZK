# CredLink ZK — Complete Technical Documentation

## What It Is

CredLink ZK is a decentralized credit scoring protocol on BNB Smart Chain Testnet (Chain ID 97). It solves the problem of **credit invisibility** — people who migrate across borders or enter DeFi lose their financial reputation. CredLink uses zero-knowledge proofs to generate a verifiable credit score from on-chain behavior without revealing the underlying data, then uses that score to reduce collateral requirements for DeFi loans.

---

## Layer Architecture (4 Layers)

```
┌─────────────────────────────────────────────────┐
│  LAYER 4: Frontend (Next.js 14)                 │
│  5 pages, wagmi hooks, SVG charts               │
├─────────────────────────────────────────────────┤
│  LAYER 3: Backend (Express.js, port 3001)       │
│  Credit analysis, AI risk, Moca auth, Passport  │
├─────────────────────────────────────────────────┤
│  LAYER 2: ZK Circuits (Circom 2.0)              │
│  3 circuits: wallet age, repayment, default     │
├─────────────────────────────────────────────────┤
│  LAYER 1: Smart Contracts (Solidity 0.8.20)     │
│  7 contracts on BSC Testnet                     │
└─────────────────────────────────────────────────┘
```

---

## LAYER 1: Smart Contracts (7 Contracts)

All deployed on BSC Testnet (Chain 97). Compiled with Solidity 0.8.20, optimizer at 200 runs.

### 1. CreditScoreZK — `0x5ED05A35D14cae38Bf7A73AeCF295320DA17dF33`

The **central registry** of the entire protocol. Every other contract reads from or writes to this.

**Score System:**
- Range: 0–1000 (clamped, never exceeds)
- Score updates happen when ZKVerifier submits a verified proof, or when LendingPool reports a repayment/default

**Tier System:**

| Tier | Name     | Score Range | Collateral Ratio |
|------|----------|-------------|------------------|
| 0    | Bronze   | 0–199       | 150%             |
| 1    | Silver   | 200–499     | 135%             |
| 2    | Gold     | 500–749     | 125%             |
| 3    | Platinum | 750–1000    | 110%             |

**User Profile struct:** `score`, `tier`, `collateralRatio`, `totalLoans`, `repaidLoans`, `lastUpdated`

**Identity Binding:**
- `bindIdentity(identityHash, wallet)` — creates a bijective (1-to-1) mapping between a Moca identity hash and a wallet address
- Once bound, the wallet is marked `isIdentityVerified = true`
- Prevents Sybil attacks: one real identity per wallet

**Reputation Decay:**
- 180 days inactive → -20 points
- 365 days inactive → -50 points
- This incentivizes ongoing participation

**Access Control (OpenZeppelin AccessControl):**
- `DEFAULT_ADMIN_ROLE` — deployer, can grant roles
- `VERIFIER_ROLE` — granted to ZKVerifier contract, allows `updateScore()`
- `LENDING_POOL_ROLE` — granted to LendingPool, allows `recordLoan()` / `recordRepayment()`

**Key Events:** `ScoreUpdated(user, newScore, newTier)`, `IdentityBound(identityHash, wallet)`

---

### 2. ZKVerifier — `0xc6a420075E19D85F350F0614A5153c4475b8718a`

The **trust boundary** between off-chain ZK proof generation and on-chain score updates.

**How verification works:**
1. Frontend generates a Groth16 proof off-chain (via backend)
2. Proof submitted to `verifyAndUpdateScore(a, b, c, publicSignals, user)`
3. Public signals array: `[walletAgeValid, repaymentValid, scoreOutput]`
4. Contract validates the proof structure
5. If valid, calls `CreditScoreZK.updateScore(user, scoreOutput, tier)`

**Current mode:** Mock verification for testnet (validates signal structure, not full Groth16 pairing). Production would use a real Groth16 verifier generated by snarkjs.

**ZK Badge gamification:**

| Badge    | Proofs Required |
|----------|----------------|
| Bronze   | 1              |
| Silver   | 3              |
| Gold     | 5              |
| Platinum | 10             |

Each successful verification increments `proofCount[user]`, unlocking badges.

---

### 3. LendingPool — `0x53c95d8dAFBD171b28B9D874C02534e7b60390E5`

The **DeFi lending engine** where actual BNB borrowing and lending happens.

**Loan lifecycle:**

```
depositToPool() → requestLoan() → [30 days] → repayLoan() → releaseCollateral()
                                              → liquidateLoan() → liquidateCollateral()
```

**For borrowers — `requestLoan()`:**
- Reads user's tier from CreditScoreZK
- Calculates required collateral: `loanAmount * collateralRatio / 100`
- User sends BNB collateral with the transaction (msg.value)
- Collateral forwarded to CollateralManager for escrow
- Creates a Loan struct: `{borrower, amount, collateral, interest, dueDate, repaid, liquidated}`
- Constraints:
  - Max 3 concurrent active loans per borrower
  - 7-day cooldown between loan requests
  - Pool utilization must stay under 80%

**Interest rates by tier:**

| Tier     | Interest |
|----------|----------|
| Bronze   | 5%       |
| Silver   | 4%       |
| Gold     | 3%       |
| Platinum | 2%       |

**For borrowers — `repayLoan(loanId)`:**
- Must pay `principal + interest` in BNB
- Must wait at least 1 hour after borrowing (flash loan prevention)
- On success: Records repayment on CreditScoreZK (+50 score), releases collateral back

**Liquidation — `liquidateLoan(loanId)`:**
- Anyone can call this if:
  - Loan is past due (> 30 days), OR
  - Collateral is undercollateralized (< 120% of loan)
- On liquidation: Collateral goes to pool, records default on CreditScoreZK (-100 score)

**For lenders — `depositToPool()`:**
- Payable function, accepts BNB
- Tracks per-lender deposits
- APY based on pool utilization:
  - 0–40%: 4% APY
  - 40–70%: 6% APY
  - 70%+: 8% APY

**Anomaly scoring:** `updateAnomalyScore(user, score)` — used for Sybil resistance, flagging suspicious borrowing patterns.

---

### 4. CollateralManager — `0xBbEd9274652F6e82f33D2777970b0719FE2f1F99`

**Single-responsibility escrow.** Holds BNB collateral in custody during active loans.

Three operations, all restricted to `LENDING_POOL_ROLE`:
- `lockCollateral(loanId, borrower)` — accepts BNB, stores `{borrower, amount, locked: true}`
- `releaseCollateral(loanId, to)` — returns BNB to borrower on repayment
- `liquidateCollateral(loanId, pool)` — sends BNB to pool on default

**Security:** Uses CEI (Checks-Effects-Interactions) pattern — state is cleared before external BNB transfer to prevent reentrancy.

`isUndercollateralized(loanId, loanAmount)` — returns true if collateral < 120% of loan amount (used by liquidation logic).

---

### 5. CreditPassportNFT — `0x154F1EAB15a878b674cae2B8BF51eE179c4Dae05`

**Soulbound ERC-721 token** — a portable, non-transferable credit credential.

- `transferFrom()`, `approve()`, `setApprovalForAll()` all **revert** — truly soulbound
- One passport per wallet (`hasMinted` mapping)
- Data encoded on-chain: score, tier, ZK verified, Moca verified, country code
- `tokenURI()` returns Base64-encoded JSON metadata directly from contract (no IPFS dependency)
- `MINTER_ROLE` can mint new passports and update existing ones

This NFT is what makes credit **portable** — a verifier on any chain can read the NFT to confirm creditworthiness.

---

### 6. CrossChainScoreOracle — `0xc91Ef659166CBf9FeBEC263d32F1EDc41eaE1bfA`

**Bridge endpoint** for cross-chain score synchronization.

- `syncScoreFromOtherChain(user, score, sourceChainId, proof)` — receives score from another chain
- `getSyncedScore(user)` → returns `{score, lastSyncTimestamp}`
- Score must be in [0, 1000] range
- `BRIDGE_ROLE` — designed for LayerZero or Axelar relayer integration

This means a score earned on BSC can be recognized on Ethereum, Polygon, etc.

---

### 7. GovernanceStub — `0xE5376869F728D464Ae445322D81b2E0ff928a970`

**On-chain parameter registry**, currently admin-controlled, designed for future DAO migration.

Configurable parameters:
- Interest rates per tier (1–20% range)
- Decay periods and penalties
- Tier score thresholds
- Max utilization (50–95%)
- Loan duration, cooldown, max concurrent loans

Migration path: Transfer `DEFAULT_ADMIN_ROLE` to a `TimelockController` for DAO governance.

---

### Contract Dependency Graph

```
                    ┌─────────────────┐
                    │  GovernanceStub  │
                    └────────┬────────┘
                             │ reads params
                    ┌────────▼────────┐
     ┌──────────────┤  CreditScoreZK  ├──────────────┐
     │              └──┬────┬────┬────┘              │
     │  updates score  │    │    │  mints passport   │
     │                 │    │    │                    │
┌────▼─────┐          │    │    │         ┌──────────▼──────────┐
│ZKVerifier│          │    │    │         │ CreditPassportNFT   │
└──────────┘          │    │    │         └─────────────────────┘
                      │    │    │
        reads score   │    │    │  bridges score
                      │    │    │
               ┌──────▼┐   │   ┌▼──────────────────────┐
               │Lending ├───┘   │ CrossChainScoreOracle │
               │ Pool   │      └───────────────────────┘
               └───┬────┘
                   │ locks/releases
             ┌─────▼──────────┐
             │CollateralManager│
             └────────────────┘
```

---

## LAYER 2: ZK Circuits (Circom 2.0)

Three circuits that prove credit-relevant facts **without revealing the raw data**.

### Circuit 1: `walletAgeProof.circom`

```
Private input:  walletAgeDays (e.g., 365)
Public input:   threshold (e.g., 30)
Output:         valid = 1 if walletAgeDays >= threshold
```

Proves: "My wallet is at least X days old" without revealing exact age.

### Circuit 2: `repaymentProof.circom`

```
Private inputs: totalLoans (e.g., 10), repaidLoans (e.g., 9)
Public input:   minRepaymentRate (e.g., 80%)
Output:         valid = 1 if (repaidLoans/totalLoans)*100 >= minRepaymentRate
```

Proves: "My repayment rate exceeds 80%" without revealing exact loan count.

### Circuit 3: `defaultRatioProof.circom`

```
Private inputs: totalLoans (e.g., 10), defaultedLoans (e.g., 1)
Public input:   maxDefaultRate (e.g., 20%)
Output:         valid = 1 if (defaultedLoans/totalLoans)*100 <= maxDefaultRate
```

Proves: "My default rate is below 20%" without revealing exact numbers.

**Score calculation** (in `generate-proof.js`):

```
score = floor(walletAge * 0.3 + repayments * 40 + (1 - defaultRatio) * 300)
clamped to [0, 1000]
```

The proofs use **Groth16** — a zk-SNARK scheme that produces constant-size proofs (3 elements: a, b, c) verifiable in constant time on-chain.

---

## LAYER 3: Backend (Express.js, Port 3001)

### Route: `/api/credit` — Credit Analysis

- **POST /analyze**: Takes wallet address, returns behavioral metrics (age, tx count, balance, estimated score, repayment history, default ratio)
- **POST /generate-proof**: Takes wallet metrics, generates Groth16-structured proof with public signals `[walletAgeValid, repaymentValid, score]`

### Route: `/api/ai` — Groq LLaMA 3 Integration

- **POST /risk-explanation**: AI generates a 2-sentence, max 60-word risk assessment based on score/tier/loan history. Uses Groq's LLaMA 3-8B model.
- **POST /anomaly-detect**: AI detects suspicious patterns (Sybil attacks, airdrop farming, wash trading). Returns `{suspicious, confidence, reason}`. Temperature 0.3 for deterministic output.

### Route: `/api/auth` — Moca Wallet OAuth

- **POST /moca**: Mock OAuth flow — receives authorization code + wallet address, generates `mocaId` and `identityHash = keccak256(mocaId)`, then calls `CreditScoreZK.bindIdentity()` on-chain using an admin signer (`ADMIN_PRIVATE_KEY`). Checks `isIdentityVerified()` first for idempotency.

### Route: `/api/identity` — Identity Management

- **POST /register**: Binds Moca ID to wallet on-chain
- **GET /verify/:wallet**: Checks if wallet has bound identity
- **GET /status/:wallet**: Returns full identity status (verified, hash, can borrow)

### Route: `/api/passport` — Public Credit Passport

- **GET /public/:wallet**: Returns full public credit profile (score, tier, ZK status, identity status, badge, loan stats)
- **GET /public/:wallet/badge**: Returns ZK badge level and proof count

---

## LAYER 4: Frontend (Next.js 14, Port 3000)

### Configuration

**Providers.tsx** — Wagmi v2 configured for BSC Testnet:

```
Chain ID: 97
RPC: https://data-seed-prebsc-1-s1.binance.org:8545
Explorer: testnet.bscscan.com
```

**AuthContext.tsx** — React Context for Moca auth state. Persists to `localStorage` keyed by wallet address. Exposes: `mocaVerified`, `identityHash`, `loginWithMoca()`, `logout()`.

**useContractData.ts** — 5 wagmi hooks for real on-chain reads:

| Hook                   | Contract Call                                 | Returns                              |
|------------------------|-----------------------------------------------|--------------------------------------|
| `useUserProfile()`     | `CreditScoreZK.getUserProfile(address)`       | score, tier, collateral ratio, loans |
| `useIdentityVerified()`| `CreditScoreZK.isIdentityVerified(address)`   | boolean                              |
| `usePoolMetrics()`     | `LendingPool.totalBorrowed()` + balance       | TVL, utilization, APY                |
| `useUserLoans()`       | `LendingPool.getLoansByBorrower(address)`      | active/repaid loans array            |
| `useScoreHistory()`    | `ScoreUpdated` events via `getLogs`            | score change timeline                |

### 5 Pages

**1. Dashboard (`/`)** — Main command center

- Score display from `getUserProfile()` (0 if no ZK proof submitted)
- Tier badge with collateral ratio
- Moca identity status card
- Capital Efficiency chart comparing all 4 tier ratios
- ZK proof generation flow (analyze → generate → submit)
- AI risk advisor (Groq-powered)
- Score Evolution line chart (from on-chain events)
- Risk Distribution doughnut (loan repayment stats)
- Protocol Architecture network graph (6 contracts visualized with real addresses)
- Bottom metrics bar: total borrowed, active loans, credit score — all from contract

**2. Borrow (`/borrow`)** — 3-step loan origination

- Step 1: Generate ZK proof (calls backend `/api/credit/analyze` then `/generate-proof`)
- Step 2: Set loan amount (shows collateral calculation: `amount * tierRatio / 100`, savings vs 150% traditional)
- Step 3: Confirm & lock (calls `LendingPool.requestLoan()` with BNB collateral as msg.value)
- Real contract interaction via `useWriteContract`

**3. Repay (`/repay`)** — Loan management

- Reads active loans from `LendingPool.getLoansByBorrower()`
- Shows each loan: ID, principal, collateral locked, interest amount, due date
- Flags overdue loans visually
- Repay button calls `LendingPool.repayLoan(loanId)` with `principal + interest` as msg.value
- Score increase indication (+50 points per repayment)

**4. Lender (`/lender`)** — Liquidity provider dashboard

- Pool stats: balance, borrowed, TVL, current APY (all from contract)
- Utilization bar with 80% threshold and APY tier indicators
- Deposit interface: calls `LendingPool.depositToPool()` as payable transaction
- Pool information card: tier-based collateral ratios, rates, constraints

**5. Travel (`/travel`)** — Credit Passport with 4 tabs

- **My Passport**: Visual card with score ring (SVG), tier badge, ZK/Moca status, downloadable QR code
- **Verify Passport**: Input any wallet address, verify their credit standing
- **Connect Moca**: Moca OAuth login, identity binding status
- **Migration Simulation**: Select origin/destination countries, see: rental deposit reduction, microloan pre-approval amount, credit transfer time, borrowing power, interest rate comparison

### 5 Chart Components (SVG-based, no dependencies)

1. **ScoreEvolutionChart** — Line/area chart from `ScoreUpdated` events
2. **CapitalEfficiencyChart** — Horizontal bars comparing tier collateral ratios
3. **TrustNetworkGraph** — Interactive network of 6 contracts with gradient connections, breathing center node, hover tooltips, animated particles
4. **RiskDistributionChart** — Doughnut chart of loan repayment stats
5. **UtilizationBar** — Gradient bar with APY tiers and pool metrics

---

## End-to-End Flow: How a Loan Actually Works

```
1. User connects MetaMask (BSC Testnet)

2. User binds Moca identity → backend calls CreditScoreZK.bindIdentity()

3. User clicks "Generate ZK Proof" on Borrow page
   → Backend analyzes wallet: age, txs, balance, repayments, defaults
   → Backend generates Groth16 proof with score + validity signals
   → Frontend submits proof to ZKVerifier.verifyAndUpdateScore()
   → ZKVerifier validates → calls CreditScoreZK.updateScore(user, score, tier)
   → User now has an on-chain credit score

4. User requests 0.1 BNB loan
   → LendingPool reads tier from CreditScoreZK (e.g., Silver = 135%)
   → Required collateral: 0.1 * 135% = 0.135 BNB
   → User sends 0.135 BNB with requestLoan() transaction
   → CollateralManager.lockCollateral() escrows the BNB
   → Loan created: 30-day duration, 4% interest (Silver tier)

5. Within 30 days, user repays
   → repayLoan(): pays 0.1 + 0.004 = 0.104 BNB
   → CollateralManager.releaseCollateral(): 0.135 BNB returned to user
   → CreditScoreZK: +50 score, repaidLoans++
   → Net cost to user: 0.004 BNB interest (saved 0.015 BNB vs 150% traditional)

6. If user defaults (>30 days):
   → Anyone calls liquidateLoan()
   → CollateralManager.liquidateCollateral(): 0.135 BNB → pool
   → CreditScoreZK: -100 score, tier potentially drops
   → Lenders made whole from collateral
```

---

## Security Model

- **Sybil resistance**: Moca identity binding (1 identity per wallet) + anomaly scoring via AI
- **Flash loan prevention**: 1-hour minimum between borrow and repay
- **Overcollateralization**: Even Platinum tier requires 110% (pool always covered)
- **Reentrancy protection**: CollateralManager uses CEI pattern
- **Role-based access**: Only ZKVerifier can update scores, only LendingPool can manage collateral
- **Utilization cap**: 80% max — pool always has liquidity buffer
- **Reputation decay**: Inactive users lose score, preventing stale high scores

---

## Deployed Contract Addresses (BSC Testnet — Chain ID 97)

| Contract              | Address                                      |
|-----------------------|----------------------------------------------|
| CreditScoreZK        | `0x5ED05A35D14cae38Bf7A73AeCF295320DA17dF33` |
| LendingPool           | `0x53c95d8dAFBD171b28B9D874C02534e7b60390E5` |
| CollateralManager     | `0xBbEd9274652F6e82f33D2777970b0719FE2f1F99` |
| ZKVerifier            | `0xc6a420075E19D85F350F0614A5153c4475b8718a` |
| CreditPassportNFT     | `0x154F1EAB15a878b674cae2B8BF51eE179c4Dae05` |
| CrossChainScoreOracle | `0xc91Ef659166CBf9FeBEC263d32F1EDc41eaE1bfA` |
| GovernanceStub        | `0xE5376869F728D464Ae445322D81b2E0ff928a970` |

---

## Tech Stack Summary

| Layer           | Technology                                      |
|-----------------|-------------------------------------------------|
| Smart Contracts | Solidity 0.8.20, OpenZeppelin 5.0, Hardhat      |
| ZK Proofs       | Circom 2.0, snarkjs 0.7.3, Groth16              |
| Blockchain      | BNB Smart Chain Testnet (Chain 97)               |
| Frontend        | Next.js 14, React 18, TypeScript, Tailwind CSS   |
| Web3            | wagmi v2, viem                                   |
| Backend         | Express.js, ethers.js v6                         |
| AI              | Groq API (LLaMA 3-8B)                           |
| Identity        | Moca Wallet (OAuth)                              |

---

**7 contracts, 3 circuits, 5 API routes, 5 pages, 5 hooks, 5 charts — all live on BSC Testnet.**
